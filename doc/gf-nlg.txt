Natural Language Generation with the Grammatical Framework
Aarne Ranta


+Introduction+

++What is NLG?++

Natural Language Generation (NLG) is a programming task where data is converted to natural language.
An example is a table that lists countries and their populations:

|| country  | population
| Argentina | 41343201 
| United States | 310232863

From this data, a very simple NLG system can produce the sentences

//The population of Argentina is 41343201.//

//The population of the United States is 310232863.//

These sentences essentially list the individual facts in the data, row by row from the table.
The system can still be useful, for instance as a device to feed the data to speech synthesis.
A step beyond this is not just to list the data point by point, but also express interesting observations or summaries based on the data.
Thus a slightly more advanced NLG system could also produce

//United States has over seven times more inhabitants than Argentina.//

which combines two facts in a hopefully interesting way.
Methods for selecting what to say about a data are traditionally a central interest of NLG research.

After selecting //what// to say, an NLG system has to define //how// to say it.
The simplest method is to use **templates**, which are sentences or texts with "holes" to which the data is inserted.
Thus a template for populations of countries might be
```
  The population of _ is _.
```
and for comparisons of two countries,
```
  _ has _ times more inhabitants than _.
```
Sooner or later, the template method may turn out insufficient, because the words belonging to the template may be different for different data values.
A typical example is the number of the noun, which should be as in

//You have 2 new messages.//

//You have 1 new message.//

Witnessing a wide-spread use of templates, it is still very common to see examples such as

//You have 1 new messages.//

//You have 1 new message(s).//

The problem is often harder for other languages than English.
Even the first example, populations of countries, which works fine in English, creates a problem in languages where country names have to be inflected.
Thus for instance in Swedish, we need the genitive form of the country.
A simple-minded template would add a genitive //s// to the name: 
```
  _s befolkning Ã¤r _.
```
This would work for most countries, but not for those whose name already ends with an //s//, such as //Mauritius//: no //s// would then be added.
This problem becomes worse in languages like Finnish, where country names are inflected in intricate ways.

To avoid the template problem, an NLG system must be aware of **grammar** so that it can select proper forms of words.
Even the order of words may have to vary as a function of what data is described.
Building in correct grammar into NLG is a nontrivial task, but it can be helped by software tools and libraries.
In this document, we will introduce the solution provided by Grammatical Framework (GF), which has been used in NLG for over 40 languages.


++What is NLG good for?++


++Who is this document for?++

This document is meant for everyone who wants to use Grammatical Framework (GF) as a tool for Natural Language Generation (NLG).
NLG was the first intended application of GF, and it is still the area where GF excels the most compared with other approaches.
This applies in particular to **multilingual NLG**, where GF is perhaps the only systematic and scalable approach supported by mature software and language resources.

Previous knowledge of GF from an introduction course (such as a summer school), the GF book (Ranta 2011), or an on-line tutorial, is useful for an in-depth understanding of the scope and limitations of GF.
However, this document is meant to be self-contained: it can be followed by anyone with a basic knowledge of programming.
What makes this possible is the GF Resource Grammar Library (RGL), which hides the linguistic details needed in multilingual NLG.
The user of the RGL only needs to master a subset of the GF programming language, since many of the more specialized features are only needed when implementing the linguistic details of a new language in the RGL.


+A gradual introduction to NLG in GF+

Let us start the work with a data set that is simple and well-known, yet rich enough to illustrate the main issues of NLG.
The set is a table with information about countries from GeoNames.
As the table is a few years old, its information is not always up to date --- but this is just an illustration of one of the main virtues of NLG, namely that it can adapt texts to changes in data!


|| Country | Capital | Area | Population | Continent | Curr.Code | Curr.Name
| Andorra | Andorra la Vella | 468 | 84000 | EU | EUR | Euro
| United Arab Emirates | Abu Dhabi | 82880 | 4975593 | AS | AED | Dirham
| Afghanistan | Kabul | 647500 | 29121286 | AS | AFN | Afghani
| Albania | Tirana | 28748 | 2986952 | EU | ALL | Lek
| Armenia | Yerevan | 29800 | 2968000 | AS | AMD | Dram
| Angola | Luanda | 1246700 | 13068161 | AF | AOA | Kwanza
| Argentina | Buenos Aires | 2766890 | 41343201 | SA | ARS | Peso
| Austria | Vienna | 83858 | 8205000 | EU | EUR | Euro
| Australia | Canberra | 7686850 | 21515754 | OC | AUD | Dollar
| Azerbaijan | Baku | 86600 | 8303512 | AS | AZN | Manat
| Bosnia and Herzegovina | Sarajevo | 51129 | 4590000 | EU | BAM | Marka
| Thailand | Bangkok | 514000 | 67089500 | AS | THB | Baht


++Atomic facts++

The first kind of things we want to express is **atomic facts** assigning **properties** to **objects**.
In our table, the objects of primary interest are the countries in the first column.
Each of the later columns assigns a different property to this object:
- The capital of Argentina is Buenos Aires.
- The area of Argentina is 2766890 square kilometres.
- The population of Argentina is 41343201.
- The continent of Argentina is South America.
- The currency of Argentina is Peso (ARS).


In the continent fact, the acronym "SA" is converted to "South America".
In the currency fact, the currency name and code are given in combination.
With these conversions, all properties have the same syntactic structure:
- The **Property** of **Object** is **Value**.


where **Property** is a noun, **Object** is a proper name, and **Value** is a number or a proper name, possibly with a code in parentheses.

















''\end{document}''

Facts like this have a simple **context-free grammar**:
```
  Fact     ::= "the" Property "of" Object "is" Value
  Property ::= "capital" | "area"
             | "population" | "continent" | "currency"
  Object   ::= Name
  Value    ::= NUMBER | Name | Name "(" Code ")"
  Name     ::= "Andorra" | "United Arab Emirates" | ...
  Code     ::= "EUR" | "AED" | ... 
```
Assuming a basic familiarity with context-free grammars, we just note that in our notation, we write **categories** (a.k.a. non-terminals) without quotes, and **tokens** (a.k.a. terminals) with quotes.
The category NUMBER is special, as we do not give any explicit rules to it, but just assume it to be defined as sequences of digits.
In contrast to this, the category Name is defined by explicitly listing the relevant names.
In this way, we will later be able to assign specific properties to each name, including translations to different languages.

The context-free grammar supports a simple NLG algorithm which can be used for generating a text for each row in the table.
Assuming that we can access the columns by the titles on the first row, we can generate a text consisting of the following sentences:
- the capital of Country is Capital
- the area of Country is Area
- the population of Country is Population
- the continent of Country is Continent
- the currency of Country is Curr.Name (Curr.Code)





