Natural Language Generation with the Grammatical Framework
Aarne Ranta


+Introduction+

++What is NLG?++

Natural Language Generation (NLG) is a programming task where data is converted to natural language.
An example is a table that lists countries and their populations:

|| country  | population
| Argentina | 41343201 
| United States | 310232863

''\noindent''
From this data, a very simple NLG system can produce the sentences
- //The population of Argentina is 41343201.//
- //The population of the United States is 310232863.//


''\noindent''
These sentences essentially list the individual facts in the data, row by row from the table.
The system can still be useful, for instance as a device to feed the data to speech synthesis.
A step beyond this is not just to list the data point by point, but also express interesting observations or summaries based on the data.
Thus a slightly more advanced NLG system could also produce
- //United States has over seven times more inhabitants than Argentina.//


''\noindent''
which combines two facts in a hopefully interesting way.
Methods for selecting what to say about a data are traditionally a central interest of NLG research.

After selecting //what// to say, an NLG system has to define //how// to say it.
The simplest method is to use **templates**, which are sentences or texts with "holes" to which the data is inserted.
Thus a template for populations of countries might be
```
  The population of _ is _.
```
''\noindent''
and for comparisons of two countries,
```
  _ has _ times more inhabitants than _.
```
''\noindent''
Sooner or later, the template method may turn out insufficient, because the words belonging to the template may be different for different data values.
A typical example is the number of the noun, which should be as in
- //You have 2 new messages.//
- //You have 1 new message.//


''\noindent''
Witnessing a wide-spread use of templates, it is still very common to see examples such as
- //You have 1 new messages.//
- //You have 1 new message(s).//


''\noindent''
The problem is often harder for other languages than English.
Even the first example, populations of countries, which works fine in English, creates a problem in languages where country names have to be inflected.
Thus for instance in Swedish, we need the genitive form of the country.
A simple-minded template would add a genitive //s// to the name: 
```
  _s befolkning Ã¤r _.
```
''\noindent''
This would work for many countries, but not for those whose name already ends with an //s//, such as //Mauritius//: no //s// would then be added.
This problem becomes worse in languages like Finnish, where country names are inflected in intricate ways.

To avoid the template problem, an NLG system must be aware of **grammar** so that it can select proper forms of words.
Even the order of words may have to vary as a function of what data is described.
Building in correct grammar into NLG is a nontrivial task, but it can be helped by software tools and libraries.
In this document, we will introduce the solution provided by Grammatical Framework (GF), which has been used in NLG for over 40 languages.


++What is NLG good for?++


++Who is this document for?++

This document is meant for everyone who wants to use Grammatical Framework (GF) as a tool for Natural Language Generation (NLG).
NLG was the first intended application of GF, and it is still the area where GF excels the most compared with other approaches.
This applies in particular to **multilingual NLG**, where GF is perhaps the only systematic and scalable approach supported by mature software and language resources.

Previous knowledge of GF from an introduction course (such as a summer school), the GF book (Ranta 2011), or an on-line tutorial, is useful for an in-depth understanding of the scope and limitations of GF.
However, this document is meant to be self-contained: it can be followed by anyone with a basic knowledge of programming.
What makes this possible is the GF Resource Grammar Library (RGL), which hides the linguistic details needed in multilingual NLG.
The user of the RGL only needs to master a subset of the GF programming language, since many of the more specialized features are only needed when implementing the linguistic details of a new language in the RGL.


+A gradual introduction to NLG in GF+

Let us start the work with a data set that is simple and well-known, yet rich enough to illustrate the main issues of NLG.
The set is a table with information about countries from GeoNames.
As the table is a few years old, its information is not always up to date --- but this is just an illustration of one of the main virtues of NLG, namely that it can adapt texts to changes in data!

''\small''
|| Country | Capital | Area | Population | Continent | Curr.Code | Curr.Name
| Andorra | Andorra la Vella | 468 | 84000 | EU | EUR | Euro
| Afghanistan | Kabul | 647500 | 29121286 | AS | AFN | Afghani
| Albania | Tirana | 28748 | 2986952 | EU | ALL | Lek
| Armenia | Yerevan | 29800 | 2968000 | AS | AMD | Dram
| Angola | Luanda | 1246700 | 13068161 | AF | AOA | Kwanza
| Argentina | Buenos Aires | 2766890 | 41343201 | SA | ARS | Peso
| Austria | Vienna | 83858 | 8205000 | EU | EUR | Euro
| Australia | Canberra | 7686850 | 21515754 | OC | AUD | Dollar
| Azerbaijan | Baku | 86600 | 8303512 | AS | AZN | Manat
| Thailand | Bangkok | 514000 | 67089500 | AS | THB | Baht
''\normalsize''

++Atomic facts++

The first kind of things we want to express is **atomic facts** assigning **properties** to **objects**.
In our table, the objects of primary interest are the countries in the first column.
Each of the later columns assigns a different property to this object:
- The capital of Argentina is Buenos Aires.
- The area of Argentina is 2766890 square kilometres.
- The population of Argentina is 41343201.
- The continent of Argentina is South America.
- The currency of Argentina is Peso.


''\noindent''
In the continent fact, the acronym "SA" is converted to "South America".
In the currency fact, only the name of the currency is given, not the code.
All properties have the same syntactic structure:
- The **Property** of **Object** is **Value**.


''\noindent''
where **Property** is a noun, **Object** is a proper name, and **Value** is a number or a proper name.

Repeating the same syntactic structure in all sentences is not a way to build a natural-looking text.
But it is already natural language and thereby serves some of the purposes of NLG.
It constitutes a baseline from which the text can be improved with various NLG techniques.
It is a **canonical representation** of the data contained in the cells of a table, where the sentences stand in one-to-one correspondance with the data itself.


++Baseline NLG code for atomic facts++

We will now start writing code for an NLG system and use atomic facts as the first step.
We will show parts of the full code, which can be found in the directory ``facts1/``.
The code consists of three kinds of files:
- GF files defining a grammar of facts
- Python files defining how data is converted to grammatical structures
- TSV (tab-separated values) files containing the data itself


''\noindent''
The focus will be on the GF files, which would not require any changes if the Python files were replaced by equivalent C, Haskell, or Java files or the TSV files with other formats such as XML or Json.
But we want to start with a full definition of a concrete, runnable system to help the readers to build their own systems.

The minimum number of GF files is two: one for an **abstract syntax** and one for a **concrete syntax**.
The abstract syntax defines a set of fact **trees** (**abstract syntax trees**), which are language-neutral representations of linguistic structures.
The concrete syntax shows how trees are **linearized**, i.e. converted to **strings** in a natural language.
The strength of GF comes from the possibility to have several concrete syntaxes, each corresponding to a different language.
Thus a multilingual NLG system can be built and extended by just adding GF modules, while leaving the Python files and data files intact.
''Figure~\ref{mnlg}'' shows the structure of an NLG system based on this idea.
'''
\begin{center}
\includegraphics[width=0.9\textwidth]{mnlg.png}
\end{center}
'''

+++Abstract syntax+++

The GF file ``Facts.gf``  defines an abstract syntax for atomic facts:
```
abstract Facts = {

cat
  Fact ;
  Object ;
  Property ;
  Value ;
  Name ;

fun
  AtomicFact : Property -> Object -> Value -> Fact ;

  capital_Property : Property ;
  area_Property : Property ;
  population_Property : Property ;
  continent_Property : Property ;
  currency_Property : Property ;

  NameObject : Name -> Object ;
  NameValue : Name -> Value ;
  IntValue : Int -> Value ;
  StringName : String -> Name ;
}
```
''\noindent''
The parts of this file are
- a **module header** indicating that this is an abstract syntax module named ``Facts``,
- a **module body**, in curly braces, consisting of two kinds of **judgements** ("rules"):
  - ``cat``, **categories** of linguistic objects,
  - ``fun``, **functions** for building such objects from 0 or more given objects.


''\noindent''
The arrow notation in ``fun`` judgements is used for **function types** to separate the **argument types** from the **value type**.
Thus the first ``fun`` judgement
```
  AtomicFact : Property -> Object -> Value -> Fact
```
''\noindent''
says that
- ``AtomicFact`` is a function that takes a ``Property``, an ``Object`` and a ``Value`` as its arguments an produces a ``Fact``  as its value.


''\noindent''
The limiting case are **constant functions**, which have no argument types --- here the five ones from ``capital_Property`` to ``currency_Property``.

The functions
```
  IntValue : Int -> Value ;
  StringName : String -> Name ;
```
''\noindent''
have as their argument types the **built-in categories** ``Int`` and ``String``.
These categories are not declared in the ``cat`` judgments and have no user-defined functions to build trees in them: their objects are given as **integer literals** (such as ``41343201``) and **string literals** (``"Argentina"``), respectively.

For other categories than the built-in ones, trees are built by combining smaller trees with functions.
Thus the representation of the sentence
- //the population of Argentina is 41343201//


''\noindent''
is a tree of type ``Fact`` built by the function ``AtomicFact`` as follows:
```
  AtomicFact
    population_Property
    (NameObject (StringName "Argentina"))
    (IntValue 41343201)
```
''\noindent''
This tree can also be shown in a graphical representation,
'''
\begin{center}
\includegraphics[width=0.6\textwidth]{argentina.png}
\end{center}
'''


+++Concrete syntax+++

A concrete syntax specifies how abstract syntax trees are linearized to strings in some language.
Our first example is the file ``FactsEng.gf``,
```
concrete FactsEng of Facts = {

lincat
  Fact = Str ;
  Object = Str ;
  Property = Str ;
  Value = Str ;
  Name = Str ;

lin
  AtomicFact prop obj val = "the" ++ prop ++ "of" ++ obj ++ "is" ++ val ;

  capital_Property = "capital" ;
  area_Property = "area" ;
  population_Property = "population" ;
  continent_Property = "continent" ;
  currency_Property = "currency" ;

  NameObject name = name ;
  NameValue name = name ;
  IntValue int = int.s ;
  StringName str = str.s ;
}
```
''\noindent''
This concrete syntax file consists of
- a module header saying that it is a concrete syntax named ``FactsEng`` of the abstract syntax ``Facts``,
- a module body containing two kinds of judgement:
  - ``lincat`` specifying the **linearization type** of each category,
  - ``lin`` specifying the **linearization function** of each function.


''\noindent''
The simplest linearization type is ``Str``, **string**.
This type is sufficient for expressing **context-free grammars** in GF.
It is too limited for full-scale NLG, but provides an easy to grasp introduction; we will extend it to richer types later.

The linearization functions are defined with expressions that combine **variables** with **string literals**.
Thus the first rule
```
  AtomicFact prop obj val = "the" ++ prop ++ "of" ++ obj ++ "is" ++ val
```
''\noindent''
uses the variables ``prop``, ``obj``, and ``val``, which stand for the arguments of the function, and the literals ``"the"``, ``"of"``, and ``"is"``.
The method of combination is **concatenation**, denoted by ``++``.

The built-in types ``Int`` and ``String`` have more complex linearization types than ``Str``.
Hence their objects cannot be used directly when a ``Str``  is expected, but extracted as a **projection** ``.s`` --- a notation that will be fully explained later.

A slight variant of ``FactsEng`` defines a concrete syntax for Finnish:
```
concrete FactsFin of Facts = {

-- lincat as in FactsEng

lin
  AtomicFact prop obj val = "maan" ++ obj ++ prop ++ "on" ++ val ;

  capital_Property = "pÃ¤Ã¤kaupunki" ;
  area_Property = "pinta-ala" ;
  population_Property = "asukasluku" ;
  continent_Property = "maanosa" ;
  currency_Property = "valuutta" ;

-- the remaining lin as in FactsEng
}
```
''\noindent''
The ``AtomicFact`` rule uses a well-known trick to avoid the genitive inflection of country names: it wraps the name with the word //maa// ("country"), which is turned into the genitive to build an equivalent of English //of the country X//.
The result is grammatically correct but extremely clumsy Finnish, which immediately reveals that text as machine-generated.
Another indicator of this is, obviously, the country names for which plain English strings are used.
Both of these problems will be solved shortly when we extend the model by a richer use of GF.


+++Python code converting data to text+++

(In this section, we assume basic knowledge of Python and will not explain all details of the language.)

The Python file ``facts1/facts.py`` reads a tsv file and a GF grammar, and prints out a linearization of every atomic fact in all of the languages covered by the grammar.
```
# import pgf, which makes GF functionalities available in Python
import pgf

# read country data from a tsv file into a named tuple
from collections import namedtuple
def get_countries(filename):
    countries = []
    Country = namedtuple('Country',
                'country capital area population continent ccode cname')
    file = open(filename)
    for line in file:
        fields = Country(*line.split('\t'))
        countries.append(fields)
    return countries

# for each tuple, build a list of GF trees, one for each atomic fact
def country_facts(c):
  object = mkApp('NameObject', [mkName(c.country)])
  return [
    mkApp('AtomicFact',[mkApp(prop,[]),object,val])
      for (prop,val) in [
        ('capital_Property',    mkApp('NameValue',[mkName(c.capital)])),
        ('area_Property',       mkApp('IntValue', [mkInt(c.area)])),
        ('population_Property', mkApp('IntValue', [mkInt(c.population)])),
        ('continent_Property',  mkApp('NameValue',[mkName(c.continent)])),
        ('currency_Property',   mkApp('NameValue',[mkName(c.cname)]))
        ]
    ]

# auxiliary functions for building trees
def mkApp(f,xs):  # applying a function to subtrees
    return pgf.Expr(f,xs)

def mkInt(s):  # building an integer literal from a string
    return pgf.readExpr(str(s))

def mkName(s): # building a Name from a string
    return mkApp('StringName',[pgf.readExpr(str('"' + s + '"'))])

# putting it all together
def main():
    gr = pgf.readPGF('facts.pgf')   # read the compiled grammar
    countries = get_countries('countries.tsv')
    langs = list(gr.languages.values())
    for lang in langs:
        text = []
        for c in countries:
            for t in country_facts(c):
                text.append(lang.linearize(t))
        print('\n'.join(text))

main()
```
''\noindent''
The grammar is in the binary **Portable Grammar Format**, **PGF**.
It can be produced from the GF source files with the shell command
```
  gf -make FactsEng.gf FactsFin.gf
```
''\noindent''
The result is a single file, ``Facts.pgf``, which can be read by Python via the classes and functions in the ``pgf`` module delivered together with GF.

Running the Python code results in 2520 sentences, stating 5 atomic facts about 252 countries in two languages:
```
$ python3 facts.py | more
the capital of Andorra is Andorra la Vella
the area of Andorra is 468
the population of Andorra is 84000
the continent of Andorra is EU
the currency of Andorra is Euro
...
maan Netherlands Antilles pÃ¤Ã¤kaupunki on Willemstad
maan Netherlands Antilles pinta-ala on 960
maan Netherlands Antilles asukasluku on 136197
maan Netherlands Antilles maanosa on NA
maan Netherlands Antilles valuutta on Guilder
```
''\noindent''
As an easy exercise for the reader, we could now suggest her to add a module for her own language:
- copy and modify ``FactsEng.gf``
- compile the pgf file with this new module included
- run the ``facts.py`` script


''\noindent''
Don't worry if it looks hopeless to get the grammar right: we will fix this by using more power of GF.


+++Testing the grammar with the GF shell+++

The GF shell, just like the Python shell, is a line-based tool that enables testing GF code while developing it.
The following session shows some useful commands in the shell:
```
# start gf in the OS shell, see the welcome message
$ gf
                              
         *  *  *              
      *           *           
    *               *         
   *                          
   *                          
   *        * * * * * *       
   *        *         *       
    *       * * * *  *        
      *     *      *          
         *  *  *              
                              
This is GF version 3.10.4. 
Built on darwin/x86_64 with ghc-8.4, flags: interrupt server c-runtime
License: see help -license.   

# no languages are available yet
Languages:

# importing (i) a GF file makes a language available
> i FactsEng.gf
linking ... OK

Languages: FactsEng
1 msec

# generate random (gr) abstract syntax tree
Facts> gr
AtomicFact area_Property (NameObject (StringName "Foo")) (IntValue 999)

0 msec

# generate random tree and pipe (|) it to linearize (l)
Facts> gr | l
the population of Foo is Foo

0 msec

# parse (p) a string into a tree
Facts> p "the capital of France is Paris"
AtomicFact capital_Property (NameObject (StringName "France")) (NameValue (StringName "Paris"))

0 msec

# import another concrete syntax for the same abstract
Facts> i FactsFin.gf
linking ... OK

Languages: FactsEng FactsFin
1 msec

# translate by parsing in one language and linearizing into another one
Facts> p -lang=Eng "the capital of France is Paris" | l -lang=Fin
maan France pÃ¤Ã¤kaupunki on Paris

0 msec

# quit (q) GF and return to the OS shell
Facts> q
See you.
0 msec
$ 
```

++Improved NLG code for atomic facts++

We will now improve the quality of NLG by making full use of GF.
The code can be found in the directory ``facts2/``.


















''\end{document}''

Facts like this have a simple **context-free grammar**:
```
  Fact     ::= "the" Property "of" Object "is" Value
  Property ::= "capital" | "area"
             | "population" | "continent" | "currency"
  Object   ::= Name
  Value    ::= NUMBER | Name | Name "(" Code ")"
  Name     ::= "Andorra" | "United Arab Emirates" | ...
  Code     ::= "EUR" | "AED" | ... 
```
Assuming a basic familiarity with context-free grammars, we just note that in our notation, we write **categories** (a.k.a. non-terminals) without quotes, and **tokens** (a.k.a. terminals) with quotes.
The category NUMBER is special, as we do not give any explicit rules to it, but just assume it to be defined as sequences of digits.
In contrast to this, the category Name is defined by explicitly listing the relevant names.
In this way, we will later be able to assign specific properties to each name, including translations to different languages.

The context-free grammar supports a simple NLG algorithm which can be used for generating a text for each row in the table.
Assuming that we can access the columns by the titles on the first row, we can generate a text consisting of the following sentences:
- the capital of Country is Capital
- the area of Country is Area
- the population of Country is Population
- the continent of Country is Continent
- the currency of Country is Curr.Name (Curr.Code)





