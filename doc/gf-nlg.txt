Natural Language Generation with the Grammatical Framework
Aarne Ranta


+Introduction+

++What is NLG?++

Natural Language Generation (NLG) is a programming task where data is converted to natural language.
An example is a table that lists countries and their populations:

|| country  | population
| Argentina | 41343201 
| United States | 310232863

''\noindent''
From this data, a very simple NLG system can produce the sentences
- //The population of Argentina is 41343201.//
- //The population of the United States is 310232863.//


''\noindent''
These sentences essentially list the individual facts in the data, row by row from the table.
The system can still be useful, for instance as a device to feed the data to speech synthesis.
A step beyond this is not just to list the data point by point, but also express interesting observations or summaries based on the data.
Thus a slightly more advanced NLG system could also produce
- //United States has over seven times more inhabitants than Argentina.//


''\noindent''
which combines two facts in a hopefully interesting way.
Methods for selecting what to say about a data are traditionally a central interest of NLG research.

After selecting //what// to say, an NLG system has to define //how// to say it.
The simplest method is to use **templates**, which are sentences or texts with "holes" to which the data is inserted.
Thus a template for populations of countries might be
```
  The population of _ is _.
```
''\noindent''
and for comparisons of two countries,
```
  _ has _ times more inhabitants than _.
```
''\noindent''
Sooner or later, the template method may turn out insufficient, because the words belonging to the template may be different for different data values.
A typical example is the number of the noun, which should be as in
- //You have 2 new messages.//
- //You have 1 new message.//


''\noindent''
Witnessing a wide-spread use of templates, it is still very common to see examples such as
- //You have 1 new messages.//
- //You have 1 new message(s).//


''\noindent''
The problem is often harder for other languages than English.
Even the first example, populations of countries, which works fine in English, creates a problem in languages where country names have to be inflected.
Thus for instance in Swedish, we need the genitive form of the country.
A simple-minded template would add a genitive //s// to the name: 
```
  _s befolkning Ã¤r _.
```
''\noindent''
This would work for many countries, but not for those whose name already ends with an //s//, such as //Mauritius//: no //s// would then be added.
This problem becomes worse in languages like Finnish, where country names are inflected in intricate ways.

To avoid the template problem, an NLG system must be aware of **grammar** so that it can select proper forms of words.
Even the order of words may have to vary as a function of what data is described.
Building in correct grammar into NLG is a nontrivial task, but it can be helped by software tools and libraries.
In this document, we will introduce the solution provided by Grammatical Framework (GF), which has been used in NLG for over 40 languages.


++What is NLG good for?++


++Who is this document for?++

This document is meant for everyone who wants to use Grammatical Framework (GF) as a tool for Natural Language Generation (NLG).
NLG was the first intended application of GF, and it is still the area where GF excels the most compared with other approaches.
This applies in particular to **multilingual NLG**, where GF is perhaps the only systematic and scalable approach supported by mature software and language resources.

Previous knowledge of GF from an introduction course (such as a summer school), the GF book (Ranta 2011), or an on-line tutorial, is useful for an in-depth understanding of the scope and limitations of GF.
However, this document is meant to be self-contained: it can be followed by anyone with a basic knowledge of programming.
What makes this possible is the GF Resource Grammar Library (RGL), which hides the linguistic details needed in multilingual NLG.
The user of the RGL only needs to master a subset of the GF programming language, since many of the more specialized features are only needed when implementing the linguistic details of a new language in the RGL.


+A gradual introduction to NLG in GF+

Let us start the work with a data set that is simple and well-known, yet rich enough to illustrate the main issues of NLG.
The set is a table with information about countries from GeoNames.
As the table is a few years old, its information is not always up to date --- but this is just an illustration of one of the main virtues of NLG, namely that it can adapt texts to changes in data!

''\small''
|| Country | Capital | Area | Population | Continent | Currency
| Andorra | Andorra la Vella | 468 | 84000 | EU | Euro
| Afghanistan | Kabul | 647500 | 29121286 | AS | Afghani
| Albania | Tirana | 28748 | 2986952 | EU | Lek
| Armenia | Yerevan | 29800 | 2968000 | AS | Dram
| Angola | Luanda | 1246700 | 13068161 | AF | Kwanza
| Argentina | Buenos Aires | 2766890 | 41343201 | SA | Peso
| Austria | Vienna | 83858 | 8205000 | EU | Euro
| Australia | Canberra | 7686850 | 21515754 | OC | Dollar
| Azerbaijan | Baku | 86600 | 8303512 | AS | Manat
| Thailand | Bangkok | 514000 | 67089500 | AS | Baht
''\normalsize''

++Atomic facts++

The first kind of things we want to express is **atomic facts** assigning **values** of **attributes** to **objects**.
In our table, the objects of primary interest are the countries in the first column.
Each of the later columns assigns a different attribute to this object:
- The capital of Argentina is Buenos Aires.
- The area of Argentina is 2766890 square kilometres.
- The population of Argentina is 41343201.
- The continent of Argentina is South America.
- The currency of Argentina is Peso.


''\noindent''
In the continent fact, the acronym "SA" is converted to "South America".
In the currency fact, only the name of the currency is given, not the code.
All facts have the same syntactic structure:
- The **Attribute** of **Object** is **Value**.


''\noindent''
where **Attribute** is a noun, **Object** is a proper name, and **Value** is a number or a proper name.

Repeating the same syntactic structure in all sentences is not a way to build a natural-looking text.
But it is already natural language and thereby serves some of the purposes of NLG.
It constitutes a baseline from which the text can be improved with various NLG techniques.
It is a **canonical representation** of the data contained in the cells of a table, where the sentences stand in one-to-one correspondance with the data itself.


++Baseline NLG code for atomic facts++

We will now start writing code for an NLG system and use atomic facts as the first step.
We will show parts of the full code, which can be found in the directory ``facts1/``.
The code consists of three kinds of files:
- GF files defining a grammar of facts
- Python files defining how data is converted to grammatical structures
- TSV (tab-separated values) files containing the data itself


''\noindent''
The focus will be on the GF files, which would not require any changes if the Python files were replaced by equivalent C, Haskell, or Java files or the TSV files with other formats such as XML or Json.
But we want to start with a full definition of a concrete, runnable system to help the readers to build their own systems.

The minimum number of GF files is two: one for an **abstract syntax** and one for a **concrete syntax**.
The abstract syntax defines a set of fact **trees** (**abstract syntax trees**), which are language-neutral representations of linguistic structures.
The concrete syntax shows how trees are **linearized**, i.e. converted to **strings** in a natural language.
The strength of GF comes from the possibility to have several concrete syntaxes, each corresponding to a different language.
Thus a multilingual NLG system can be built and extended by just adding GF modules, while leaving the Python files and data files intact.
''Figure~\ref{mnlg}'' shows the structure of an NLG system based on this idea.
'''
\begin{center}
\includegraphics[width=0.9\textwidth]{mnlg.png}
\end{center}
'''

+++Abstract syntax+++

The GF file ``Facts.gf``  defines an abstract syntax for atomic facts:
```
abstract Facts = {

cat
  Fact ;
  Object ;
  Attribute ;
  Value ;
  Name ;

fun
  AtomicFact : Attribute -> Object -> Value -> Fact ;

  capital_Attribute : Attribute ;
  area_Attribute : Attribute ;
  population_Attribute : Attribute ;
  continent_Attribute : Attribute ;
  currency_Attribute : Attribute ;

  NameObject : Name -> Object ;
  NameValue : Name -> Value ;
  IntValue : Int -> Value ;
  StringName : String -> Name ;
}
```
''\noindent''
The parts of this file are
- a **module header** indicating that this is an abstract syntax module named ``Facts``,
- a **module body**, in curly braces, consisting of two kinds of **judgements** ("rules"):
  - ``cat``, **categories** of linguistic objects,
  - ``fun``, **functions** for building such objects from 0 or more given objects.


''\noindent''
The arrow notation in ``fun`` judgements is used for **function types** to separate the **argument types** from the **value type**.
Thus the first ``fun`` judgement
```
  AtomicFact : Attribute -> Object -> Value -> Fact
```
''\noindent''
says that
- ``AtomicFact`` is a function that takes a ``Attribute``, an ``Object`` and a ``Value`` as its arguments an produces a ``Fact``  as its value.


''\noindent''
The limiting case are **constant functions**, which have no argument types --- here the five ones from ``capital_Attribute`` to ``currency_Attribute``.

The functions
```
  IntValue : Int -> Value ;
  StringName : String -> Name ;
```
''\noindent''
have as their argument types the **built-in categories** ``Int`` and ``String``.
These categories are not declared in the ``cat`` judgments and have no user-defined functions to build trees in them: their objects are given as **integer literals** (such as ``41343201``) and **string literals** (``"Argentina"``), respectively.

For other categories than the built-in ones, trees are built by combining smaller trees with functions.
Thus the representation of the sentence
- //the population of Argentina is 41343201//


''\noindent''
is a tree of type ``Fact`` built by the function ``AtomicFact`` as follows:
```
  AtomicFact
    population_Attribute
    (NameObject (StringName "Argentina"))
    (IntValue 41343201)
```
''\noindent''
This tree can also be shown in a graphical representation,
'''
\begin{center}
\includegraphics[width=0.6\textwidth]{argentina.eps}
\end{center}
'''


+++Concrete syntax+++

A concrete syntax specifies how abstract syntax trees are linearized to strings in some language.
Our first example is the file ``FactsEng.gf``,
```
concrete FactsEng of Facts = {

lincat
  Fact = Str ;
  Object = Str ;
  Attribute = Str ;
  Value = Str ;
  Name = Str ;

lin
  AtomicFact prop obj val = "the" ++ prop ++ "of" ++ obj ++ "is" ++ val ;

  capital_Attribute = "capital" ;
  area_Attribute = "area" ;
  population_Attribute = "population" ;
  continent_Attribute = "continent" ;
  currency_Attribute = "currency" ;

  NameObject name = name ;
  NameValue name = name ;
  IntValue int = int.s ;
  StringName str = str.s ;
}
```
''\noindent''
This concrete syntax file consists of
- a module header saying that it is a concrete syntax named ``FactsEng`` of the abstract syntax ``Facts``,
- a module body containing two kinds of judgement:
  - ``lincat`` specifying the **linearization type** of each category,
  - ``lin`` specifying the **linearization function** of each function.


''\noindent''
The simplest linearization type is ``Str``, **string**.
This type is sufficient for expressing **context-free grammars** in GF.
It is too limited for full-scale NLG, but provides an easy to grasp introduction; we will extend it to richer types later.

The linearization functions are defined with expressions that combine **variables** with **string literals**.
Thus the first rule
```
  AtomicFact prop obj val = "the" ++ prop ++ "of" ++ obj ++ "is" ++ val
```
''\noindent''
uses the variables ``prop``, ``obj``, and ``val``, which stand for the arguments of the function, and the literals ``"the"``, ``"of"``, and ``"is"``.
The method of combination is **concatenation**, denoted by ``++``.

The built-in types ``Int`` and ``String`` have more complex linearization types than ``Str``.
Hence their objects cannot be used directly when a ``Str``  is expected, but extracted as a **projection** ``.s`` --- a notation that will be fully explained later.

A slight variant of ``FactsEng`` defines a concrete syntax for Finnish:
```
concrete FactsFin of Facts = {

-- lincat as in FactsEng

lin
  AtomicFact prop obj val = "maan" ++ obj ++ prop ++ "on" ++ val ;

  capital_Attribute = "pÃ¤Ã¤kaupunki" ;
  area_Attribute = "pinta-ala" ;
  population_Attribute = "asukasluku" ;
  continent_Attribute = "maanosa" ;
  currency_Attribute = "valuutta" ;

-- the remaining lin as in FactsEng
}
```
''\noindent''
The ``AtomicFact`` rule uses a well-known trick to avoid the genitive inflection of country names: it wraps the name with the word //maa// ("country"), which is turned into the genitive to build an equivalent of English //of the country X//.
The result is grammatically correct but extremely clumsy Finnish, which immediately reveals that text as machine-generated.
Another indicator of this is, obviously, the country names for which plain English strings are used.
Both of these problems will be solved shortly when we extend the model by a richer use of GF.


+++Python code converting data to text+++

(In this section, we assume basic knowledge of Python and will not explain all details of the language.)

The Python file ``facts1/facts.py`` reads a tsv file and a GF grammar, and prints out a linearization of every atomic fact in all of the languages covered by the grammar.
```
# import pgf, which makes GF functionalities available in Python
import pgf

# read country data from a tsv file into a named tuple
from collections import namedtuple
def get_countries(filename):
    countries = []
    Country = namedtuple('Country',
                'country capital area population continent currency')
    file = open(filename)
    for line in file:
        fields = Country(*line.split('\t'))
        countries.append(fields)
    return countries

# for each tuple, build a list of GF trees, one for each atomic fact
def country_facts(c):
  object = mkApp('NameObject', [mkName(c.country)])
  return [
    mkApp('AtomicFact',[mkApp(prop,[]),object,val])
      for (prop,val) in [
        ('capital_Attribute',    mkApp('NameValue',[mkName(c.capital)])),
        ('area_Attribute',       mkApp('IntValue', [mkInt(c.area)])),
        ('population_Attribute', mkApp('IntValue', [mkInt(c.population)])),
        ('continent_Attribute',  mkApp('NameValue',[mkName(c.continent)])),
        ('currency_Attribute',   mkApp('NameValue',[mkName(c.currency)]))
        ]
    ]

# auxiliary functions for building trees
def mkApp(f,xs):  # applying a function to subtrees
    return pgf.Expr(f,xs)

def mkInt(s):  # building an integer literal from a string
    return pgf.readExpr(str(s))

def mkName(s): # building a Name from a string
    return mkApp('StringName',[pgf.readExpr(str('"' + s + '"'))])

# putting it all together
def main():
    gr = pgf.readPGF('facts.pgf')   # read the compiled grammar
    countries = get_countries('countries.tsv')
    langs = list(gr.languages.values())
    for lang in langs:
        text = []
        for c in countries:
            for t in country_facts(c):
                text.append(lang.linearize(t))
        print('\n'.join(text))

main()
```
''\noindent''
The grammar is in the binary **Portable Grammar Format**, **PGF**.
It can be produced from the GF source files with the shell command
```
  gf -make FactsEng.gf FactsFin.gf
```
''\noindent''
The result is a single file, ``Facts.pgf``, which can be read by Python via the classes and functions in the ``pgf`` module delivered together with GF.

Running the Python code results in 2520 sentences, stating 5 atomic facts about 252 countries in two languages:
```
$ python3 facts.py | more
the capital of Andorra is Andorra la Vella
the area of Andorra is 468
the population of Andorra is 84000
the continent of Andorra is EU
the currency of Andorra is Euro
...
maan Netherlands Antilles pÃ¤Ã¤kaupunki on Willemstad
maan Netherlands Antilles pinta-ala on 960
maan Netherlands Antilles asukasluku on 136197
maan Netherlands Antilles maanosa on NA
maan Netherlands Antilles valuutta on Guilder
```
''\noindent''


+++Testing the grammar with the GF shell+++

The GF shell, just like the Python shell, is a line-based tool that enables testing GF code while developing it.
The following session shows some useful commands in the shell:
```
# start gf in the OS shell, see the welcome message
$ gf
                              
         *  *  *              
      *           *           
    *               *         
   *                          
   *                          
   *        * * * * * *       
   *        *         *       
    *       * * * *  *        
      *     *      *          
         *  *  *              
                              
This is GF version 3.10.4. 
Built on darwin/x86_64 with ghc-8.4, flags: interrupt server c-runtime
License: see help -license.   

# no languages are available yet
Languages:

# importing (i) a GF file makes a language available
> i FactsEng.gf
linking ... OK

Languages: FactsEng
1 msec

# generate random (gr) abstract syntax tree
Facts> gr
AtomicFact area_Attribute (NameObject (StringName "Foo")) (IntValue 999)

0 msec

# generate random tree and pipe (|) it to linearize (l)
Facts> gr | l
the population of Foo is Foo

0 msec

# parse (p) a string into a tree
Facts> p "the capital of France is Paris"
AtomicFact capital_Attribute (NameObject (StringName "France")) (NameValue (StringName "Paris"))

0 msec

# import another concrete syntax for the same abstract
Facts> i FactsFin.gf
linking ... OK

Languages: FactsEng FactsFin
1 msec

# translate by parsing in one language and linearizing into another one
Facts> p -lang=Eng "the capital of France is Paris" | l -lang=Fin
maan France pÃ¤Ã¤kaupunki on Paris

0 msec

# quit (q) GF and return to the OS shell
Facts> q
See you.
0 msec
$ 
```
+++Exercises+++

===Add a language===

As an easy exercise for the reader, we could now suggest her to add a module for her own language:
- copy and modify ``FactsEng.gf``
- compile the pgf file with this new module included
- run the ``facts.py`` script


''\noindent''
Don't worry if it looks hopeless to get the grammar right: we will fix this by using more power of GF.


===Change the data===

The ``Facts`` grammar is completely general for any kind of data that can be presented in the format "the Attribute of Object is Value", except for the names of the attributes and the wrapper word ``maan`` in ``FactsFin.gf``.
You can hence apply it to some other tabular data, with the following modifications: 
- in ``facts.py``,
  - change ``get_countries()`` to reflect the number and meaning of the fields in your data,
  - change ``country_facts()`` to select the facts you want to display and the proper grammar functions for them;


- in ``Facts*.gf``,
  - change the set of Attribute functions and their linearizations,
  - if necessary, change the wrapper words used in different languages.


===Semantic triples===

The data format "the Attribute of Object is Value" is a special case of **semantic triples**, such as those used in RDF (**Resource Description Framework**).
RDF if a standard format for storing data on the web and is used, for example, in Wikidata, which is a data resource for the Wikipedia.
Thus in Wikidata, the fact that Cairo is the capital of Egypt is represented as the triple
```
  wd:Q85 wdt:P1376 wd:Q79
```
''\noindent''
where ``wd:Q85`` is an identifier for Cairo, ``wd:Q79`` for Egypt, and ``wdt:Q85`` for the relation "is the capital of".

Wikidata is accessible via its query interface https://query.wikidata.org/.
In this interface, one can write queries in the SPARQL language (**SPARQL Protogol and RDF Query Language**) and get answers in a tabular form.
For example, the following SPARQL query generates a table of countries and their capitals:
```
select ?city ?country ?cityLabel ?countryLabel {
  ?country wdt:P31 wd:Q6256 .
  ?city wdt:P31 wd:Q515 .
  ?city wdt:P1376 ?country .
  ?city rdfs:label ?cityLabel .
  filter(lang(?cityLabel) = 'en') .
  ?country rdfs:label ?countryLabel .
  filter(lang(?countryLabel) = 'en')
}
```
''\noindent''
The result is displayed as a table in the web browser, but it can also be downloaded in the TSV format.
This gives a direct way to apply the methods seen by now to Wikidata.
What is more, it also gives a way to obtain translations of names, by varying the language code (e.g. from ``en`` to ``fi``).

We will return to RDF and Wikidata many times later, but you can get a first feeling of it by writing some query, downloading the result as TSV, and using the result in the way explained in the previous exercise.







++Improving the NLG code for atomic facts++

We will now improve the quality of NLG by making full use of GF.
The code for this can be found in the directory ``facts2/``.
The main improvents are
- going from static templates to grammatical structures,
- thereby enabling more fluent language,
- translating the names to different languages,
- restructuring the code so that it is easier to extend.


''\noindent''
These improvements are based on two new concepts of GF:
- the **Resource Grammar Library** (RGL), giving an easy access to grammar rules,
- the **module system**, enabling a modular structure of the code.



+++Refactoring abstract syntax+++

The GF code in ``facts1/``  is monolithic: there is just one GF file for the abstract syntax and one for each language.
This file contains both generic concepts about facts and concepts specific for countries.
If we want to apply it on some other domain, such as novels, we have to make a copy of the code and change some parts of it.
A better way to do this is to divide the code into a generic and domain-specific part:
- ``Facts.gf``, defining general categories and syntactic structures,
- ``Countries.gf``, defining domain-specific concepts, such as the attributes,


''\noindent''
In addition, we will now introduce a third kind of a module,
- ``CountryNames.gf``, defining the names of countries, cities, and currencies.


''\noindent''
These three modules are organized hierarchically, so that ``Countries`` is the **top module**, which **inherits** from the other two modules.
The hierarchy can be visualized in GF by using the command ``dg``; see "help dg" in the GF shell for details about its use.
The resulting graph looks as follows:
'''
\begin{center}
\includegraphics[width=0.4\textwidth]{countriesAbs.eps}
\end{center}
'''

The generic ``Facts`` module is now a proper part of the earlier ``Facts`` module:
```
abstract Facts = {

cat
  Fact ;
  Object ;
  Attribute ;
  Value ;
  Name ;

fun
  AtomicFact : Attribute -> Object -> Value -> Fact ;

  NameObject : Name -> Object ;
  NameValue : Name -> Value ;
  IntValue : Int -> Value ;

}
```
''\noindent''
Notice that, in additions to the country-specific attributes, we have left out the ``StringName`` function that builds names from string literals.
The reason is that we now want to introduce names as abstract syntax identifiers, so that we can linearize them in language-specific ways.
This brings us to the module ``CountryNames``:
```
abstract CountryNames = {

cat CName ;

-- manually added: continent names
fun AF_CName : CName ;
fun AS_CName : CName ;
fun EU_CName : CName ;
fun NA_CName : CName ;
fun OC_CName : CName ;
fun SA_CName : CName ;

-- generated
fun 'Basse-Terre_CName' : CName ;
fun 'St._John\'s_CName' : CName ;
fun Abu_Dhabi_CName : CName ;
fun Abuja_CName : CName ;
--- followed by hundreds more names
}
```
This module contains
- domain-specific name categories, here just ``CName``, but we could also have different categories for countries, cities, and currencies,
- manually defined names, here just the continents
- names extracted from data, here for all countries, cities, and currencies


''\noindent''
The rationale with domain-specific categories will become obvious later.
One reason is that different categories can have different properties, for instance, from a country name one can form an expression for a citizen of that country, which is not possible for some other types of names.

Extracting names from data can be done in different ways.
For example, the Wikimedia identifiers (such as ``wd:Q79`` for Egypt) would work well as an abstract function names.
Here we have, however, used the English names to make it easier to manually inspect the grammar.
The important thing in both cases is to make sure the function names are valid GF identifiers.
This means, among other things, surrounding them by single quotes if they contain special characters.
The function
```
  extract_names.mkFun(name,category)
```
''\noindent''
in ``facts2/extract_names.py`` is a way to guarantee this.
The same module also has the function ``name_rules()``, which forms a pair of GF ``fun`` and ``lin`` rules for a name.

The topmost module ``Countries`` inherits both ``Facts`` and ``CountryNames``, to which it adds some code of its own:
```
abstract Countries = Facts, CountryNames ** {
fun
-- using CNames
  cName : CName -> Name ;

-- basic properties
  capital_Attribute : Attribute ;
  area_Attribute : Attribute ;
  population_Attribute : Attribute ;
  continent_Attribute : Attribute ;
  currency_Attribute : Attribute ;

-- specialized expressions for properties
  populationFact : CName -> Int -> Fact ;
  continentFact : CName -> CName -> Fact ;
}
```
''\noindent''
The main parts are
- a header that lists the inherited modules and adds (with operator ``**``) a body of new judgements,
- functions for using domain-specific names in the general category ``Name``,
- domain-specific attributes,
- other domain-specific functions, which enable idiomatic expressions of facts.


''\noindent''
The last part is a main ingredient in making NLG more natural.
It introduces alternative ways for expressing facts --- in the present case,
- //Argentina has 41343201 inhabitants// (``populationFact``)
- //Argentina is in South America// (``continentFact``)



+++Refactoring concrete syntax+++

The concrete syntax is usually, although not necessarily, divided into modules parallel to the abstract syntax.
The module structure then looks as follows:
'''
\begin{center}
\includegraphics[width=0.6\textwidth]{countriesEngFin.eps}
\end{center}
'''
''\noindent''
The graph generated by ``dg`` uses
- rectangles for abstract modules,
- ellipses for concrete modules,
- solid arrow heads for inheritance,
- hollow arrow heads for the concrete-abstract relation.


''\noindent''
Just to refactor ``FactsEng`` in this way would not require more explanation.
But we will now introduce a new concept: the use of **resource modules** with reusable operations.
The first one out is ``FactsEng``:
```
concrete FactsEng of Facts = open SyntaxEng, SymbolicEng in {

lincat
  Fact = Cl ;
  Object = NP ;
  Attribute = CN ;
  Value = NP ;
  Name = NP ;

lin
  AtomicFact prop obj val = mkCl (mkNP the_Det (mkCN prop (mkAdv possess_Prep obj))) val ;
  NameObject name = name ;
  NameValue name = name ;
  IntValue int = symb int ;
}
```
''\noindent''
The only new notation in this module is the ``open`` directive on the first line.
It means that the contents of the two modules, ``SyntaxEng`` and ``SymbolicEng``, become usable in the module body.
But the contents are not inherited --- in fact, this would not even make sense, because the opened modules are not concrete syntaxes but of yet a different kind, **resource modules**.

We do not need to write any resource modules ourselves at this point, but just use those available in the RGL (GF Resource Grammar Library).
The three most important modules are, for each language with its language code as suffix,
- ``Syntax``, which contains syntactic categories and functions,
- ``Paradigms``, which contains operations for inflecting words,
- ``Symbolic``, which enables the use of numeric and other literals in syntactic structures.


''\noindent''
The RGL is installed in a standard, although platform-specific, place in the file system, where the GF compiler finds it via the environment variable ``GF_LIB_PATH``.
If you can import ``FactsEng`` without error messages in GF, the installation works as it should, and you do not need to worry about it.
Then you can study the contents of the library via its API,
- https://www.grammaticalframework.org/lib/doc/synopsis/


''\noindent''
Instead of a systematic RGL tutorial, let us focus on the parts relevant to the current task.
The first objective is to define linearization types in terms of RGL categories.
The ones used in ``FactsEng`` are
- ``Cl``, **clause**, sentences expressing simple predications,
- ``NP``, **noun phrase**, phrases usable as subjects and objects in clauses,
- ``CN``, **common noun**, phrases usable as parts of noun phrases by adding determiners.


''\noindent''
The difference between ``NP`` and ``CN`` may be tricky for the non-linguist.
To give an example, //country// is a ``CN``, from which one can form ``NP``s such as //the country//, //these countries//.
Thus a ``CN`` has both singular and plural forms, whereas an ``NP`` already has a fixed number, either singular or plural.

The authors of the RGL have to define in detail
- how the forms of ``CN``s are built: //country-countries// vs.\ //continent-continents//;
- how the forms are used in ``NP``s: //this country// vs.\ //these countries//;
- how ``NP``s are used in ``Cl``s:  //this country **is** in Europe// vs.\ //these countries **are** in Europe//;


''\noindent''
Since this linguistic ground work has been done once and for all in the RGL, we NLG engineers do not need to repeat it.
But we do need to develop an idea about what combinations are possible for these categories.
The linearization of ``AtomicFact`` is quite a mouthful to start with:
```
  mkCl (mkNP the_Det (mkCN prop (mkAdv possess_Prep obj))) val
```
''\noindent''
Let us work out an example to see how it fits this pattern:
- //the capital of Italy is Rome//


''\noindent''
The outermost part of the GF expression is ``mkCl`` applied to two ``NP``s, presented as follows in the API:
```
  mkCl : NP -> NP -> Cl  -- she is the woman
```
''\noindent''
The example following the type of the function contains two ``NP``s, //she// and //the woman//, which get connected with the **copula** //is// (or //are// or //am//, depending on the first ``NP``).
Applying this to our example, we have an expression of the form
```
  mkCl <the capital of Italy> <Rome>
```
''\noindent''
Both of the two arguments are ``NP``s, as guaranteed by the ``lincat``s of ``Object`` and ``Value``, respectively.
The ``Object`` part needs to be analysed further.
It uses the following API functions, which we now annotate with the current example rather than the API documentation:
```
  mkNP    : Det -> CN -> NP    -- the capital of Italy
  the_Det : Det                -- the
  mkCN    : CN -> Adv -> CN    -- capital of Italy
  mkAdv   : Prep -> NP -> Adv  -- of Italy
  possess_Prep : Prep          -- of
```
''\noindent''
We recommend you to convince yourself that the functions are combined in a proper way, so that the value types of each subexpression match the expected argument types!
Once we manage to build a **type-correct** expression in this way from RGL function, we can be sure that the result is **grammatically correct**.
Of course, it may not be the expression you want: to guarantee this, you need to test your grammar (e.g.\ with random generation and linearization) and gradually gain experience that reduces the need of testing.

The remaining judgements in **FactsEng** are simple.
``IntValue`` uses the RGL operation
```
  symb : Int -> NP  -- 23
```
''\noindent''
Notice that we no more need to care about how a string is projected from ``Int``, as we had to do in ``facts1/``.
As a rule of thumb,
- The only form of GF expression that is needed in concrete syntax when the RGL is used is function application.



+++Defining the concrete syntax lexicon+++

The concrete syntax of ``CountryNames`` opens ``SyntaxEng`` and now also ``ParadigmsEng``:
```
concrete CountryNamesEng of CountryNames = 
  open SyntaxEng, ParadigmsEng in {

lincat CName = NP ;

oper mkCName : Str -> NP = \s -> mkNP (mkPN s) ;

-- manual
lin AF_CName = mkCName "Africa" ;
lin AS_CName = mkCName "Asia" ;
lin EU_CName = mkCName "Europe" ;
lin NA_CName = mkCName "North America" ;
lin OC_CName = mkCName "Oceania" ;
lin SA_CName = mkCName "South America" ;

-- generated
lin 'Basse-Terre_CName' = mkCName "Basse-Terre" ;
lin 'St._John\'s_CName' = mkCName "St. John's" ;
lin 'U.S._Virgin_Islands_CName' = mkCName "U.S. Virgin Islands" ;
lin Abu_Dhabi_CName = mkCName "Abu Dhabi" ;
lin Abuja_CName = mkCName "Abuja" ;
```
''\noindent''
A new kind of judgement is used:
```
  oper mkCName : Str -> NP = \s -> mkNP (mkPN s)
```
''\noindent''
defining neither a function nor its linearization but an **auxiliary operation**, which is used in ``lin`` definitions.
The operation ``mkCName`` is simple, using
- ``mkNP : PN -> NP`` from ``SyntaxEng``, using a ``PN`` (**proper name**) as an ``NP``
- ``mkPN : Str -> PN`` from ``ParadigmsEng``, building a ``PN`` from a string


''\noindent''
One could of course use the combination of those directly in each ``lin`` rule.
But it is generally a good practice to define a specific ``mk``//C// operation for every category //C//.
Then it can be easily varied if for instance the linearization type of //C// changes.

The category ``CName``and the operation ``mkCName`` can also be enriched with more information than just a plain proper name string.
Examples include
- //United States//, which in some contexts appears with the definite article and also has alternative names such as //USA//
- //British Virgin Islands//, which is treated as a plural noun phrase


''\noindent''
We will return to this question when discussing the Finnish implementation, which is impossible to get working with just plain strings.


+++The top module+++

The top module ``CountriesEng`` offers almost nothing new in terms of GF:
```
concrete CountriesEng of Countries = FactsEng, CountryNamesEng **
  open SyntaxEng, ParadigmsEng, SymbolicEng in {

lin
  cName name = name ;

  capital_Attribute = mkAttribute "capital" ;
  area_Attribute = mkAttribute "area" ;
  population_Attribute = mkAttribute "population" ;
  continent_Attribute = mkAttribute "continent" ;
  currency_Attribute = mkAttribute "currency" ;

  populationFact obj int = mkCl obj have_V2 (mkNP <symb int : Card> (mkN "inhabitant")) ;
  continentFact obj name = mkCl obj (SyntaxEng.mkAdv in_Prep name) ;

oper
  mkAttribute : Str -> CN = \s -> mkCN (mkN s) ;
}
```
The only new constructs are
- the **type annotation** ``<symb int : Card>``,
- the **qualified name** ``SyntaxEng.mkAdv``


''\noindent''
The type annotation is needed for **overload resolution**: the RGL operation ``symb`` is **overloaded**, i.e. the same function name is used for several different functions, which only differ as for their type:
```
  symb : Int -> NP    -- 23 (is prime)
  symb : Int -> Card  -- 23 (houses)
  symb : Str -> NP    -- x
```
Overloading is used throughout the RGL to keep the number of function names manageable.
It is usually resolved correctly by the type checker of GF --- but in this very case, this did not happen, so we added a type annotation to guide the type checker.

The qualified name is needed because both ``SyntaxEng`` and ``ParadigmsEng`` define an operation called ``mkAdv``.
Conceptually, one would expect the choice to be made by overload resolution, because these operations have different types.
For complicated technical reasons, this has not (yet) been implemented in GF.

Now that we have walked through the refactored modules using the RGL, we can draw the full picture of the module structure that shows both abstract, concrete, and resource modules:
'''
\begin{center}
\includegraphics[width=1.0\textwidth]{countriesEng.eps}
\end{center}
'''
''\noindent''
Resource modules are shown as dashed ellipses and opening them as dashed arrows.
This diagram hides the dozens of modules that underlie the explicitly opened RGL modules.
The user of the RGL seldom needs to be aware of them.


+++Python code+++


+++The Finnish implementation+++


+++Sharing code via a functor+++


++Building a text++

+++Referring expressions+++

+++Syntactic aggregation+++


++Data aggregation and content planning++






























''\end{document}''

Facts like this have a simple **context-free grammar**:
```
  Fact     ::= "the" Attribute "of" Object "is" Value
  Attribut ::= "capital" | "area"
             | "population" | "continent" | "currency"
  Object   ::= Name
  Value    ::= NUMBER | Name | Name "(" Code ")"
  Name     ::= "Andorra" | "United Arab Emirates" | ...
  Code     ::= "EUR" | "AED" | ... 
```
Assuming a basic familiarity with context-free grammars, we just note that in our notation, we write **categories** (a.k.a. non-terminals) without quotes, and **tokens** (a.k.a. terminals) with quotes.
The category NUMBER is special, as we do not give any explicit rules to it, but just assume it to be defined as sequences of digits.
In contrast to this, the category Name is defined by explicitly listing the relevant names.
In this way, we will later be able to assign specific properties to each name, including translations to different languages.

The context-free grammar supports a simple NLG algorithm which can be used for generating a text for each row in the table.
Assuming that we can access the columns by the titles on the first row, we can generate a text consisting of the following sentences:
- the capital of Country is Capital
- the area of Country is Area
- the population of Country is Population
- the continent of Country is Continent
- the currency of Country is Curr.Name (Curr.Code)





